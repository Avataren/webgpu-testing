# Code Review

## Overview
This repository provides a modular WebGPU renderer written in Rust with both native and WebAssembly targets. The engine layers the ECS (`hecs`), asset caches, renderer, and app orchestration cleanly, and includes optional egui integration, GPU-driven particle simulation, and utilities for HDR environments.

## Strengths
- **Extensible application pipeline.** `AppBuilder` exposes startup, CPU, and GPU stages along with a plugin trait, making it straightforward for downstream crates to register systems without touching the core loop. This keeps the update/render separation explicit and testable.【F:src/app.rs†L46-L120】
- **Targeted regression coverage for math-heavy code.** The `shadow_pipeline` tests numerically validate the CPU projection helpers against the shader logic, catching subtle axis or clip-space regressions before they hit the GPU.【F:tests/shadow_pipeline.rs†L1-L195】 Likewise, the `RenderContext` MSAA helper has unit tests that pin expected fallback behaviour.【F:src/renderer/internal/context.rs†L246-L297】
- **Well-factored GPU subsystems.** The GPU particle system cleanly splits compute, material, and render responsibilities and reuses the renderer’s global bind layouts, which simplifies integration with the rest of the frame graph.【F:src/gpu_particles.rs†L200-L503】

## Issues & Recommendations
1. **Duplicate light buffer uploads each frame.** `Scene::render` calls `renderer.set_lights(&lights)` before handing the batch to `Renderer::render`, but `Renderer::render` also writes the same `LightsData` back into the GPU buffers. This doubles the queue traffic and can become a frame-time hotspot once the light payload grows. Consider removing the external `set_lights` call and letting `Renderer::render` own that write (or make `set_lights` cache the data instead of re-uploading immediately).【F:src/scene/scene_core.rs†L125-L140】【F:src/renderer/renderer_core.rs†L234-L299】
2. **Bindless-only particle rendering panics on unsupported hardware.** `Renderer::textures_bind_group()` unwraps the bindless bind group and panics when the backend falls back to the classic texture binding model. The GPU particle renderer then always asks for that bind group, so the feature currently hard-crashes on adapters that lack `TEXTURE_BINDING_ARRAY`/non-uniform indexing (common on WebGPU/older GPUs). Please add a graceful fallback path—either disable GPU-driven particles when bindless textures are unavailable or supply a classic-material rendering variant.【F:src/renderer/renderer_core.rs†L172-L180】【F:src/renderer/internal/pipeline.rs†L780-L805】【F:src/gpu_particles.rs†L461-L503】
3. **WASM startup can panic before the renderer finishes initializing.** In the WebAssembly code path, `WindowEvent::RedrawRequested` calls `begin_frame()` unconditionally, but when the async renderer is still pending `Scene::last_frame()` has not been initialized and the call will panic (`"Scene timer not initialized"`). Guard the redraw handler so it skips the frame entirely until `self.renderer` is set, or initialize the scene timer before scheduling redraws on the web path.【F:src/app.rs†L269-L387】【F:src/app.rs†L783-L812】【F:src/scene/scene_core.rs†L35-L50】

## Additional Suggestions
- The custom render callback introduced in `App::render_scene` is useful for bespoke passes. Exposing a shared encoder hook before the internal queue submit would avoid the extra device submission when downstream code only needs to append to the main command list.【F:src/app.rs†L548-L625】
- Document the HDR asset loading expectations for the web build (currently the default HDR path fails silently on browsers because it relies on `image::open`). A note in the README or a web-specific loader would help prevent confusion.【F:src/app.rs†L396-L404】【F:src/renderer/internal/environment.rs†L65-L125】
